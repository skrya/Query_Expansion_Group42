!SESSION 2014-03-21 18:09:24.688 -----------------------------------------------
eclipse.buildId=I20110613-1736
java.version=1.6.0_30
java.vendor=Sun Microsystems Inc.
BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=en_IN
Command-line arguments:  -os linux -ws gtk -arch x86_64

!ENTRY org.eclipse.jdt.ui 4 10001 2014-03-21 22:22:55.884
!MESSAGE Internal Error
!STACK 1
Java Model Exception: Java Model Status [Timed out while retrieving the attached javadoc for IOException {key=Ljava/io/IOException;} [in IOException.class [in java.io [in /usr/lib/jvm/java-6-openjdk-amd64/jre/lib/rt.jar]]] ]
	at org.eclipse.jdt.internal.core.JavaElement.getURLContents(JavaElement.java:808)
	at org.eclipse.jdt.internal.core.BinaryType.getJavadocContents(BinaryType.java:1037)
	at org.eclipse.jdt.internal.core.BinaryType.getAttachedJavadoc(BinaryType.java:995)
	at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2.getHTMLContent(JavadocContentAccess2.java:462)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:621)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:567)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:559)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:142)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)
!SUBENTRY 1 org.eclipse.jdt.core 4 1012 2014-03-21 22:22:55.886
!MESSAGE Timed out while retrieving the attached javadoc for IOException {key=Ljava/io/IOException;} [in IOException.class [in java.io [in /usr/lib/jvm/java-6-openjdk-amd64/jre/lib/rt.jar]]] 

!ENTRY org.eclipse.ui 4 0 2014-03-22 00:15:11.720
!MESSAGE Unable to create editor ID org.eclipse.jdt.ui.ClassFileEditor: The Class File Viewer cannot handle the given input ('org.eclipse.ui.ide.FileStoreEditorInput').
!STACK 1
org.eclipse.core.runtime.CoreException: The Class File Viewer cannot handle the given input ('org.eclipse.ui.ide.FileStoreEditorInput').
	at org.eclipse.jdt.internal.ui.javaeditor.ClassFileEditor.doSetInput(ClassFileEditor.java:652)
	at org.eclipse.ui.texteditor.AbstractTextEditor$19.run(AbstractTextEditor.java:3200)
	at org.eclipse.jface.operation.ModalContext.runInCurrentThread(ModalContext.java:464)
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:372)
	at org.eclipse.jface.window.ApplicationWindow$1.run(ApplicationWindow.java:759)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)
	at org.eclipse.jface.window.ApplicationWindow.run(ApplicationWindow.java:756)
	at org.eclipse.ui.internal.WorkbenchWindow.run(WorkbenchWindow.java:2649)
	at org.eclipse.ui.texteditor.AbstractTextEditor.internalInit(AbstractTextEditor.java:3218)
	at org.eclipse.ui.texteditor.AbstractTextEditor.init(AbstractTextEditor.java:3245)
	at org.eclipse.ui.internal.EditorManager.createSite(EditorManager.java:828)
	at org.eclipse.ui.internal.EditorReference.createPartHelper(EditorReference.java:647)
	at org.eclipse.ui.internal.EditorReference.createPart(EditorReference.java:465)
	at org.eclipse.ui.internal.WorkbenchPartReference.getPart(WorkbenchPartReference.java:595)
	at org.eclipse.ui.internal.EditorReference.getEditor(EditorReference.java:289)
	at org.eclipse.ui.internal.WorkbenchPage.busyOpenEditorBatched(WorkbenchPage.java:2945)
	at org.eclipse.ui.internal.WorkbenchPage.busyOpenEditor(WorkbenchPage.java:2850)
	at org.eclipse.ui.internal.WorkbenchPage.access$11(WorkbenchPage.java:2842)
	at org.eclipse.ui.internal.WorkbenchPage$10.run(WorkbenchPage.java:2793)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)
	at org.eclipse.ui.internal.WorkbenchPage.openEditor(WorkbenchPage.java:2789)
	at org.eclipse.ui.internal.WorkbenchPage.openEditor(WorkbenchPage.java:2773)
	at org.eclipse.ui.internal.WorkbenchPage.openEditor(WorkbenchPage.java:2756)
	at org.eclipse.ui.ide.IDE.openEditorOnFileStore(IDE.java:1155)
	at org.eclipse.ui.internal.ide.actions.OpenLocalFileAction.run(OpenLocalFileAction.java:107)
	at org.eclipse.ui.internal.ide.actions.OpenLocalFileAction.run(OpenLocalFileAction.java:76)
	at org.eclipse.ui.internal.PluginAction.runWithEvent(PluginAction.java:251)
	at org.eclipse.ui.internal.WWinPluginAction.runWithEvent(WWinPluginAction.java:229)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:584)
	at org.eclipse.jface.action.ActionContributionItem.access$2(ActionContributionItem.java:501)
	at org.eclipse.jface.action.ActionContributionItem$5.handleEvent(ActionContributionItem.java:411)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1258)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3588)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3209)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:2701)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2665)
	at org.eclipse.ui.internal.Workbench.access$4(Workbench.java:2499)
	at org.eclipse.ui.internal.Workbench$7.run(Workbench.java:679)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:668)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:123)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:344)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:179)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:622)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:622)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:577)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1410)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1386)
!SUBENTRY 1 org.eclipse.jdt.ui 4 996 2014-03-22 00:15:11.722
!MESSAGE The Class File Viewer cannot handle the given input ('org.eclipse.ui.ide.FileStoreEditorInput').

!ENTRY org.eclipse.ui 2 2 2014-03-22 00:15:11.825
!MESSAGE Ignored attempt to add saveable that was already registered
!STACK 0
org.eclipse.core.runtime.AssertionFailedException: unknown saveable: org.eclipse.ui.internal.DefaultSaveable@3f08e57f from part: org.eclipse.ui.internal.ErrorEditorPart@3f08e57f
	at org.eclipse.ui.internal.SaveablesList.logWarning(SaveablesList.java:187)
	at org.eclipse.ui.internal.SaveablesList.addModel(SaveablesList.java:117)
	at org.eclipse.ui.internal.SaveablesList.addModels(SaveablesList.java:289)
	at org.eclipse.ui.internal.SaveablesList.postOpen(SaveablesList.java:695)
	at org.eclipse.ui.internal.PartList.partOpened(PartList.java:234)
	at org.eclipse.ui.internal.PartList.access$0(PartList.java:210)
	at org.eclipse.ui.internal.PartList$1.propertyChanged(PartList.java:40)
	at org.eclipse.ui.internal.WorkbenchPartReference.fireInternalPropertyChange(WorkbenchPartReference.java:375)
	at org.eclipse.ui.internal.WorkbenchPartReference.getPart(WorkbenchPartReference.java:610)
	at org.eclipse.ui.internal.EditorReference.getEditor(EditorReference.java:289)
	at org.eclipse.ui.internal.WorkbenchPage.busyOpenEditorBatched(WorkbenchPage.java:2945)
	at org.eclipse.ui.internal.WorkbenchPage.busyOpenEditor(WorkbenchPage.java:2850)
	at org.eclipse.ui.internal.WorkbenchPage.access$11(WorkbenchPage.java:2842)
	at org.eclipse.ui.internal.WorkbenchPage$10.run(WorkbenchPage.java:2793)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)
	at org.eclipse.ui.internal.WorkbenchPage.openEditor(WorkbenchPage.java:2789)
	at org.eclipse.ui.internal.WorkbenchPage.openEditor(WorkbenchPage.java:2773)
	at org.eclipse.ui.internal.WorkbenchPage.openEditor(WorkbenchPage.java:2756)
	at org.eclipse.ui.ide.IDE.openEditorOnFileStore(IDE.java:1155)
	at org.eclipse.ui.internal.ide.actions.OpenLocalFileAction.run(OpenLocalFileAction.java:107)
	at org.eclipse.ui.internal.ide.actions.OpenLocalFileAction.run(OpenLocalFileAction.java:76)
	at org.eclipse.ui.internal.PluginAction.runWithEvent(PluginAction.java:251)
	at org.eclipse.ui.internal.WWinPluginAction.runWithEvent(WWinPluginAction.java:229)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:584)
	at org.eclipse.jface.action.ActionContributionItem.access$2(ActionContributionItem.java:501)
	at org.eclipse.jface.action.ActionContributionItem$5.handleEvent(ActionContributionItem.java:411)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1258)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3588)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3209)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:2701)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2665)
	at org.eclipse.ui.internal.Workbench.access$4(Workbench.java:2499)
	at org.eclipse.ui.internal.Workbench$7.run(Workbench.java:679)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:668)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:123)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:344)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:179)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:622)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:622)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:577)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1410)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1386)
!SESSION 2014-03-31 21:40:12.638 -----------------------------------------------
eclipse.buildId=I20110613-1736
java.version=1.6.0_30
java.vendor=Sun Microsystems Inc.
BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=en_IN
Command-line arguments:  -os linux -ws gtk -arch x86_64

!ENTRY org.eclipse.core.resources 2 10035 2014-03-31 21:40:33.868
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.
!SESSION 2014-04-02 22:04:18.379 -----------------------------------------------
eclipse.buildId=I20110613-1736
java.version=1.6.0_30
java.vendor=Sun Microsystems Inc.
BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=en_IN
Command-line arguments:  -os linux -ws gtk -arch x86_64

!ENTRY org.eclipse.jdt.ui 4 10001 2014-04-03 07:15:25.468
!MESSAGE Internal Error
!STACK 1
Java Model Exception: Java Model Status [Timed out while retrieving the attached javadoc for TreeMap [in TreeMap.class [in java.util [in /usr/lib/jvm/java-6-openjdk-amd64/jre/lib/rt.jar]]] ]
	at org.eclipse.jdt.internal.core.JavaElement.getURLContents(JavaElement.java:808)
	at org.eclipse.jdt.internal.core.BinaryType.getJavadocContents(BinaryType.java:1037)
	at org.eclipse.jdt.internal.core.BinaryMethod.getAttachedJavadoc(BinaryMethod.java:643)
	at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2.getHTMLContent(JavadocContentAccess2.java:462)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:621)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:567)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:559)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:142)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)
!SUBENTRY 1 org.eclipse.jdt.core 4 1012 2014-04-03 07:15:25.474
!MESSAGE Timed out while retrieving the attached javadoc for TreeMap [in TreeMap.class [in java.util [in /usr/lib/jvm/java-6-openjdk-amd64/jre/lib/rt.jar]]] 
!SESSION 2014-04-11 06:24:38.326 -----------------------------------------------
eclipse.buildId=I20110613-1736
java.version=1.6.0_30
java.vendor=Sun Microsystems Inc.
BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=en_IN
Command-line arguments:  -os linux -ws gtk -arch x86_64

!ENTRY org.eclipse.core.resources 2 10035 2014-04-11 06:24:46.523
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.
!SESSION 2014-04-17 14:52:50.714 -----------------------------------------------
eclipse.buildId=I20110613-1736
java.version=1.6.0_30
java.vendor=Sun Microsystems Inc.
BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=en_IN
Command-line arguments:  -os linux -ws gtk -arch x86_64

!ENTRY org.eclipse.jdt.core 4 4 2014-04-17 15:39:09.964
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import org.apache.lucene.document.Document;
import org.apache.lucene.document.Field.Store;
import org.apache.lucene.index.DirectoryReader;
import org.apache.lucene.index.IndexReader;
import org.apache.lucene.index.IndexWriter;
import org.apache.lucene.index.Terms;
import org.apache.lucene.index.TermsEnum;
import org.apache.lucene.store.FSDirectory;
import org.apache.lucene.util.BytesRef;
import com.google.common.collect.Ordering;
import com.google.common.collect.TreeMultimap;

public class ClusterTags {
	public static void addDocument(IndexWriter writer, String f)
			throws IOException {
		Document doc = new Document();
		FileReader fr = new FileReader(f);
		BufferedReader br = new BufferedReader(fr, 30000);
		doc.add(new VecTextField("Content", br, Store.NO));
		writer.addDocument(doc);
	}

	public static void main(String[] args) throws NumberFormatException,
			IOException {
		HashMap<Integer, Integer> docIdToClusterNumber = new HashMap<Integer, Integer>(); //docid to clusterno
		HashMap<Integer, ArrayList<Integer>> clusterNoToDocIds = new HashMap<Integer, ArrayList<Integer>>(); // clusterno to docids
		HashMap<Integer, Integer> ourIDToInternalID = new HashMap<Integer, Integer>(); // ourid to internalid
		
		System.out.println(Constants.PATH_OF_CLUSTER_FILE);
		BufferedReader brCluster = new BufferedReader(new FileReader(new File(Constants.PATH_OF_CLUSTER_FILE)));
		System.out.println("Here2");
		//
		String line = "";
		int i = 1;
		while ((line = brCluster.readLine()) != null) {
			Integer clusterNumber = Integer.parseInt(line);
			ArrayList<Integer> arr = clusterNoToDocIds.get(clusterNumber);
			if (arr != null) {
				arr.add(i);
				clusterNoToDocIds.put(clusterNumber, arr);
			} else {
				arr = new ArrayList<Integer>();
				arr.add(i);
				clusterNoToDocIds.put(clusterNumber, arr);

			}
			docIdToClusterNumber.put(i, clusterNumber);
			i++;
		}
		// clusterno and corresponding array of docids. 
		System.out.println("Here1");
		brCluster.close();

		Map<Integer, String> IdToNameMapping = new HashMap<Integer, String>();
		BufferedReader mappingFile = new BufferedReader(new FileReader(
				new File(Constants.PATH_OF_MAPPING_FILE)));

		while ((line = mappingFile.readLine()) != null) {
			String[] parts = line.split(",");
			int num = Integer.parseInt(parts[0]);
			IdToNameMapping.put(num, parts[1]);
		}
       // each id is mapped to file name.
		
		HashSet<String> stopWordsHM = new HashSet<String>();
		try{
			FileInputStream fstream = new FileInputStream("src/StopWords.txt");
			DataInputStream in = new DataInputStream(fstream);			
	    	BufferedReader br = new BufferedReader(new InputStreamReader(in));
	    	String strLine;
	    	while ((strLine = br.readLine()) != null) {
	    		stopWordsHM.add(strLine);
	    	}
	    	in.close();
		}
		catch(Exception e)
		{
			System.out.println("File for stop words not found");
		}
		
		//Stopwords are added to stopWordsHM
		
		int noOfClusters = clusterNoToDocIds.size();
		BufferedWriter bw = new BufferedWriter(new FileWriter(new File(Constants.PATH_OF_TOP_TERMS_FOR_CLUSTER)));
		BufferedWriter dbug = new BufferedWriter(new FileWriter(new File(Constants.PATH_OF_DEBUG_LOG)));
		
		IndexReader reader = DirectoryReader.open(FSDirectory
				.open(new File(
						Constants.PATH_OF_TERM_VECTOR_INDEX_FILES)));
		// All input doc saved with fields and corresponding content.
		
		System.out.println("reader.numDocs()" + reader.numDocs());
		System.out.println("11reader.maxDoc()" + reader.maxDoc());
		
		for(int i1=0;i1<reader.maxDoc();i1++)
		{
			Document d = reader.document(i1);
			int ID = Integer.parseInt(d.get("DocID"));
			System.out.println("ID"+ID);
            ourIDToInternalID.put(ID, i1);				
//			Terms vector = reader.getTermVector(i, "Content");
//			TermsEnum termsEnum = null;
//			termsEnum = vector.iterator(termsEnum);
//			BytesRef text = null;
//			//dbug.write();
//			while ((text = termsEnum.next()) != null) {
//				System.out.println((text.utf8ToString()+ " "));
//			}
//			dbug.newLine();
//			dbug.flush();
//			 
		}// docid given as field in reader(individualindex) mapped to our normal id.
		
		Stemmer stemmer = new Stemmer();
		
		for (int clusterNumber = 0; clusterNumber < noOfClusters; clusterNumber++) {
			Map<String, Integer> frequencies = new HashMap<String, Integer>();
			Map<String, Integer> inversefrequencies = new HashMap<String, Integer>();
			
			HashMap<String,String> stemToWord = new HashMap<String,String>();
			System.out.println("docs in a cluster" + clusterNoToDocIds.get(clusterNumber).size());
			int szz = clusterNoToDocIds.get(clusterNumber).size();
			
			for (Integer docInCluster : clusterNoToDocIds.get(clusterNumber)) {
				//every doc in a cluster.
				
				System.out.println(docInCluster);
				
				Terms terms = reader.getTermVector(ourIDToInternalID.get(docInCluster), "Content");
				
				//check what is stored in  terms
				
				//dbug.write("DOCINCLUSTER = "+docInCluster);
				dbug.write("ourIDToInternalID.get(docInCluster) = "+ourIDToInternalID.get(docInCluster));
				TermsEnum termsEnum = null;
				
				termsEnum = terms.iterator(termsEnum);
				//System.out.println("sizeof docs" +docInCluster + ":" + terms.getSumDocFreq() + " " + termsEnum.docFreq());
				//termsEnum steps through all terms in a doc.
				int totaldocfreq = (int) terms.getSumDocFreq();
				BytesRef text = null;
				while ((text = termsEnum.next()) != null) {
					//System.out.println(text);
					int freq = (int) (termsEnum.totalTermFreq());
					//termsEnum.
					
					String textString = text.utf8ToString();
					
					dbug.write("t=" + textString + " f=" + freq+ " ");
					// System.out.println("term = " + term + " freq = " + freq);
					
					stemmer.add(textString.toCharArray(),textString.length());
					stemmer.stem();
					String stemmedVersion = stemmer.toString();
					String originalWord = stemToWord.get(stemmedVersion);
					if(originalWord != null){
						
						textString = originalWord;
					}
					else{
						//textString = stemmer.toString();
						stemToWord.put(stemmer.toString(),textString);
					}
					if(stopWordsHM.contains(textString)){
						continue;
					}
					if(textString.length()<3)
						continue;
					try{
						String checkString = textString.charAt(0) + "";
						
						
					    Float.parseFloat(checkString);
					}
					catch (Exception e) {
						// TODO: handle exception
						//frequencies of terms over different docs is calculated here.
						if (frequencies.get(textString) != null) {
							
							//if(textString == "background"){
							//if(freq>1){
								
							//}//}
							inversefrequencies.put(textString,frequencies.get(textString) + 1 );
							frequencies.put(textString, frequencies.get(textString) + freq +1 );
						} else {
							inversefrequencies.put(textString,1);
							frequencies.put(textString, freq + 1);
						}
					}
					
				}
				//System.in.read();
			}
			int total=0;
			for (Map.Entry<String, Integer> eeeeee : frequencies.entrySet()){
			 total +=  eeeeee.getValue();}
			TreeMultimap<Integer, String> freqToTerm = TreeMultimap.create(Ordering.natural().reverse(), Ordering.natural()); //TODO: USE Tf-Idf instead of Tf
			//TreeMultimap is used to order key,value pairs
			
			for (Map.Entry<String, Integer> eeeeee : frequencies.entrySet()) {
				freqToTerm.put((int) ((eeeeee.getValue()(1/))), eeeeee.getKey());
			}
			//*100/total)*(Math.log((szz+10)/(inversefrequencies.get(eeeeee.getKey())+10)
			System.out.println("clusterNo = " + clusterNumber);
			bw.write(new Integer(clusterNumber).toString());
			
			int clusterSize = (clusterNoToDocIds.get(clusterNumber).size());
			dbug.write(new Integer(clusterNumber).toString() + ",");
			dbug.write("Size = "+new Integer(clusterSize).toString() + " - ");
			for(Integer docID : clusterNoToDocIds.get(clusterNumber))
			{
				dbug.write(new Integer(docID).toString() + ",");
			}
			i = 0;
			
			for (Map.Entry<Integer, String> e : freqToTerm.entries()) {
				if(i > Constants.TOP_K_TERMS_IN_CLUSTER)
					break;
				
				dbug.write(","+e.getValue() + "("+e.getKey()+")");
				bw.write(","+e.getValue()+":"+e.getKey());
				i++;
			}
			//We pick most frequent TOP_K_TERMS_IN_CLUSTER per cluster and store along with their frequencies.
			
			bw.newLine();
			dbug.newLine();
		}
        bw.close();
        dbug.close();


	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1089)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1594)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:2900)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1509)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:939)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1540)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2454)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1105)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2384)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1706)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2374)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1105)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2384)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2405)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:233)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:203)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:258)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:518)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1079)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2014-04-17 15:39:09.984
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1089)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1594)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:2900)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1509)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:939)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1540)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2454)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1105)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2384)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1706)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2374)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1105)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2384)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2405)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:233)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:203)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:258)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:518)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1079)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2014-04-17 15:39:09.986
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1089)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1594)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:2900)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1509)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:939)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1540)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2454)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1105)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2384)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1706)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2374)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1105)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2384)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2405)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:233)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:203)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:258)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:518)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1079)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1244)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.core 4 4 2014-04-17 15:39:10.492
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import org.apache.lucene.document.Document;
import org.apache.lucene.document.Field.Store;
import org.apache.lucene.index.DirectoryReader;
import org.apache.lucene.index.IndexReader;
import org.apache.lucene.index.IndexWriter;
import org.apache.lucene.index.Terms;
import org.apache.lucene.index.TermsEnum;
import org.apache.lucene.store.FSDirectory;
import org.apache.lucene.util.BytesRef;
import com.google.common.collect.Ordering;
import com.google.common.collect.TreeMultimap;

public class ClusterTags {
	public static void addDocument(IndexWriter writer, String f)
			throws IOException {
		Document doc = new Document();
		FileReader fr = new FileReader(f);
		BufferedReader br = new BufferedReader(fr, 30000);
		doc.add(new VecTextField("Content", br, Store.NO));
		writer.addDocument(doc);
	}

	public static void main(String[] args) throws NumberFormatException,
			IOException {
		HashMap<Integer, Integer> docIdToClusterNumber = new HashMap<Integer, Integer>(); //docid to clusterno
		HashMap<Integer, ArrayList<Integer>> clusterNoToDocIds = new HashMap<Integer, ArrayList<Integer>>(); // clusterno to docids
		HashMap<Integer, Integer> ourIDToInternalID = new HashMap<Integer, Integer>(); // ourid to internalid
		
		System.out.println(Constants.PATH_OF_CLUSTER_FILE);
		BufferedReader brCluster = new BufferedReader(new FileReader(new File(Constants.PATH_OF_CLUSTER_FILE)));
		System.out.println("Here2");
		//
		String line = "";
		int i = 1;
		while ((line = brCluster.readLine()) != null) {
			Integer clusterNumber = Integer.parseInt(line);
			ArrayList<Integer> arr = clusterNoToDocIds.get(clusterNumber);
			if (arr != null) {
				arr.add(i);
				clusterNoToDocIds.put(clusterNumber, arr);
			} else {
				arr = new ArrayList<Integer>();
				arr.add(i);
				clusterNoToDocIds.put(clusterNumber, arr);

			}
			docIdToClusterNumber.put(i, clusterNumber);
			i++;
		}
		// clusterno and corresponding array of docids. 
		System.out.println("Here1");
		brCluster.close();

		Map<Integer, String> IdToNameMapping = new HashMap<Integer, String>();
		BufferedReader mappingFile = new BufferedReader(new FileReader(
				new File(Constants.PATH_OF_MAPPING_FILE)));

		while ((line = mappingFile.readLine()) != null) {
			String[] parts = line.split(",");
			int num = Integer.parseInt(parts[0]);
			IdToNameMapping.put(num, parts[1]);
		}
       // each id is mapped to file name.
		
		HashSet<String> stopWordsHM = new HashSet<String>();
		try{
			FileInputStream fstream = new FileInputStream("src/StopWords.txt");
			DataInputStream in = new DataInputStream(fstream);			
	    	BufferedReader br = new BufferedReader(new InputStreamReader(in));
	    	String strLine;
	    	while ((strLine = br.readLine()) != null) {
	    		stopWordsHM.add(strLine);
	    	}
	    	in.close();
		}
		catch(Exception e)
		{
			System.out.println("File for stop words not found");
		}
		
		//Stopwords are added to stopWordsHM
		
		int noOfClusters = clusterNoToDocIds.size();
		BufferedWriter bw = new BufferedWriter(new FileWriter(new File(Constants.PATH_OF_TOP_TERMS_FOR_CLUSTER)));
		BufferedWriter dbug = new BufferedWriter(new FileWriter(new File(Constants.PATH_OF_DEBUG_LOG)));
		
		IndexReader reader = DirectoryReader.open(FSDirectory
				.open(new File(
						Constants.PATH_OF_TERM_VECTOR_INDEX_FILES)));
		// All input doc saved with fields and corresponding content.
		
		System.out.println("reader.numDocs()" + reader.numDocs());
		System.out.println("11reader.maxDoc()" + reader.maxDoc());
		
		for(int i1=0;i1<reader.maxDoc();i1++)
		{
			Document d = reader.document(i1);
			int ID = Integer.parseInt(d.get("DocID"));
			System.out.println("ID"+ID);
            ourIDToInternalID.put(ID, i1);				
//			Terms vector = reader.getTermVector(i, "Content");
//			TermsEnum termsEnum = null;
//			termsEnum = vector.iterator(termsEnum);
//			BytesRef text = null;
//			//dbug.write();
//			while ((text = termsEnum.next()) != null) {
//				System.out.println((text.utf8ToString()+ " "));
//			}
//			dbug.newLine();
//			dbug.flush();
//			 
		}// docid given as field in reader(individualindex) mapped to our normal id.
		
		Stemmer stemmer = new Stemmer();
		
		for (int clusterNumber = 0; clusterNumber < noOfClusters; clusterNumber++) {
			Map<String, Integer> frequencies = new HashMap<String, Integer>();
			Map<String, Integer> inversefrequencies = new HashMap<String, Integer>();
			
			HashMap<String,String> stemToWord = new HashMap<String,String>();
			System.out.println("docs in a cluster" + clusterNoToDocIds.get(clusterNumber).size());
			int szz = clusterNoToDocIds.get(clusterNumber).size();
			
			for (Integer docInCluster : clusterNoToDocIds.get(clusterNumber)) {
				//every doc in a cluster.
				
				System.out.println(docInCluster);
				
				Terms terms = reader.getTermVector(ourIDToInternalID.get(docInCluster), "Content");
				
				//check what is stored in  terms
				
				//dbug.write("DOCINCLUSTER = "+docInCluster);
				dbug.write("ourIDToInternalID.get(docInCluster) = "+ourIDToInternalID.get(docInCluster));
				TermsEnum termsEnum = null;
				
				termsEnum = terms.iterator(termsEnum);
				//System.out.println("sizeof docs" +docInCluster + ":" + terms.getSumDocFreq() + " " + termsEnum.docFreq());
				//termsEnum steps through all terms in a doc.
				int totaldocfreq = (int) terms.getSumDocFreq();
				BytesRef text = null;
				while ((text = termsEnum.next()) != null) {
					//System.out.println(text);
					int freq = (int) (termsEnum.totalTermFreq());
					//termsEnum.
					
					String textString = text.utf8ToString();
					
					dbug.write("t=" + textString + " f=" + freq+ " ");
					// System.out.println("term = " + term + " freq = " + freq);
					
					stemmer.add(textString.toCharArray(),textString.length());
					stemmer.stem();
					String stemmedVersion = stemmer.toString();
					String originalWord = stemToWord.get(stemmedVersion);
					if(originalWord != null){
						
						textString = originalWord;
					}
					else{
						//textString = stemmer.toString();
						stemToWord.put(stemmer.toString(),textString);
					}
					if(stopWordsHM.contains(textString)){
						continue;
					}
					if(textString.length()<3)
						continue;
					try{
						String checkString = textString.charAt(0) + "";
						
						
					    Float.parseFloat(checkString);
					}
					catch (Exception e) {
						// TODO: handle exception
						//frequencies of terms over different docs is calculated here.
						if (frequencies.get(textString) != null) {
							
							//if(textString == "background"){
							//if(freq>1){
								
							//}//}
							inversefrequencies.put(textString,frequencies.get(textString) + 1 );
							frequencies.put(textString, frequencies.get(textString) + freq +1 );
						} else {
							inversefrequencies.put(textString,1);
							frequencies.put(textString, freq + 1);
						}
					}
					
				}
				//System.in.read();
			}
			int total=0;
			for (Map.Entry<String, Integer> eeeeee : frequencies.entrySet()){
			 total +=  eeeeee.getValue();}
			TreeMultimap<Integer, String> freqToTerm = TreeMultimap.create(Ordering.natural().reverse(), Ordering.natural()); //TODO: USE Tf-Idf instead of Tf
			//TreeMultimap is used to order key,value pairs
			
			for (Map.Entry<String, Integer> eeeeee : frequencies.entrySet()) {
				freqToTerm.put((int) ((eeeeee.getValue()(1/))), eeeeee.getKey());
			}
			//*100/total)*(Math.log((szz+10)/(inversefrequencies.get(eeeeee.getKey())+10)
			System.out.println("clusterNo = " + clusterNumber);
			bw.write(new Integer(clusterNumber).toString());
			
			int clusterSize = (clusterNoToDocIds.get(clusterNumber).size());
			dbug.write(new Integer(clusterNumber).toString() + ",");
			dbug.write("Size = "+new Integer(clusterSize).toString() + " - ");
			for(Integer docID : clusterNoToDocIds.get(clusterNumber))
			{
				dbug.write(new Integer(docID).toString() + ",");
			}
			i = 0;
			
			for (Map.Entry<Integer, String> e : freqToTerm.entries()) {
				if(i > Constants.TOP_K_TERMS_IN_CLUSTER)
					break;
				
				dbug.write(","+e.getValue() + "("+e.getKey()+")");
				bw.write(","+e.getValue()+":"+e.getKey());
				i++;
			}
			//We pick most frequent TOP_K_TERMS_IN_CLUSTER per cluster and store along with their frequencies.
			
			bw.newLine();
			dbug.newLine();
		}
        bw.close();
        dbug.close();


	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1089)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1594)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:2900)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1509)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:939)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1540)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2454)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1105)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2384)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1706)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2374)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1105)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2384)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2405)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:289)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 2 2014-04-17 15:39:10.494
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1089)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1594)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:2900)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1509)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:939)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1540)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2454)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1105)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2384)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1706)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2374)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1105)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2384)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2405)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:289)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2014-04-17 15:39:10.495
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1089)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1594)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:2900)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1509)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:939)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1540)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2454)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1105)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2384)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1706)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2374)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1105)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2384)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2405)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2659)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1220)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:289)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)
